<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Window Drawing Tool â€” Unified Canvas</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #toolbar { display: flex; flex-wrap: wrap; background: #333; padding: 8px; gap: 6px; }
    #toolbar button, #toolbar select { padding: 6px 10px; font-size: 14px; }
    #container { position: relative; background: #ddd; }
    #bg { display: block; width: 100%; height: auto; }
    #canvas { position: absolute; top: 0; left: 0; cursor: crosshair; }
  </style>
</head>
<body>
  <div id="toolbar">
    <select id="tool">
      <option value="select">Select</option>
      <option value="line">Line</option>
      <option value="rect">Rectangle</option>
      <option value="circle">Circle</option>
      <option value="delete">Delete</option>
    </select>
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
    <button id="clearBtn">Clear All</button>
    <button id="downloadBtn">Download PNG</button>
  </div>
  <div id="container">
    <img id="bg" src="data:image/png;base64,/* paste your form bg base64 here */" alt="Window Form" />
    <canvas id="canvas"></canvas>
  </div>

  <script>
  (() => {
    const img = document.getElementById('bg');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = img.clientWidth;
      canvas.height = img.clientHeight;
      drawAll();
    }
    img.onload = resizeCanvas;
    window.addEventListener('resize', resizeCanvas);

    let tool = 'select';
    document.getElementById('tool').onchange = e => { tool = e.target.value; deselect(); };
    document.getElementById('undoBtn').onclick = undo;
    document.getElementById('redoBtn').onclick = redo;
    document.getElementById('clearBtn').onclick = clearAll;
    document.getElementById('downloadBtn').onclick = downloadPNG;
    document.addEventListener('keydown', e => { if(e.key === 'Delete') deleteSelected(); });

    let shapes = [], undoStack = [], redoStack = [];
    let current = null, selected = null, startX = 0, startY = 0, dragMode = '';
    const handleSize = 8;

    canvas.addEventListener('mousedown', e => {
      const { x, y } = getCursor(e);
      startX = x; startY = y;

      if (tool === 'select') {
        const hit = shapes.slice().reverse().find(s => s.contains(x, y));
        if (hit) {
          selectShape(hit, x, y);
        } else deselect();
      } else if (tool === 'delete') {
        const hit = shapes.slice().reverse().find(s => s.contains(x, y));
        if (hit) { saveState(); shapes = shapes.filter(s => s !== hit); drawAll(); }
      } else {
        saveState();
        current = createShape(tool, x, y, 0, 0);
        shapes.push(current);
      }
    });

    canvas.addEventListener('mousemove', e => {
      if (!current && !selected) return;
      const { x, y } = getCursor(e);

      if (tool === 'select' && selected) {
        if (dragMode === 'move') {
          selected.move(x - startX, y - startY);
          startX = x; startY = y;
        } else if (dragMode.startsWith('resize')) {
          selected.resize(dragMode, x, y, startX, startY);
          startX = x; startY = y;
        }
      } else if (current) {
        current.update(x - startX, y - startY);
      }
      drawAll();
    });

    canvas.addEventListener('mouseup', () => {
      current = null;
      dragMode = '';
    });

    function getCursor(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
    }

    function saveState() {
      undoStack.push(shapes.map(s => s.clone()));
      redoStack = [];
    }

    function undo() {
      if (undoStack.length) {
        redoStack.push(shapes);
        shapes = undoStack.pop().map(s => s.clone());
        drawAll();
      }
    }

    function redo() {
      if (redoStack.length) {
        undoStack.push(shapes);
        shapes = redoStack.pop().map(s => s.clone());
        drawAll();
      }
    }

    function clearAll() {
      saveState();
      shapes = [];
      drawAll();
    }

    function downloadPNG() {
      const tmp = document.createElement('canvas');
      tmp.width = canvas.width; tmp.height = canvas.height;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(img, 0, 0, tmp.width, tmp.height);
      shapes.forEach(s => s.draw(tctx));
      const link = document.createElement('a');
      link.href = tmp.toDataURL('image/png');
      link.download = 'window-drawing.png';
      link.click();
    }

    function deselect() {
      selected = null;
      dragMode = '';
      drawAll();
    }

    function deleteSelected() {
      if (selected) {
        saveState();
        shapes = shapes.filter(s => s !== selected);
        deselect();
      }
    }

    function selectShape(shape, x, y) {
      selected = shape;
      dragMode = shape.getHandleUnder(x, y) || (shape.contains(x, y) ? 'move' : '');
      startX = x; startY = y;
    }

    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      shapes.forEach(s => s.draw(ctx));
      if (selected) selected.drawHandles(ctx);
    }

    function createShape(type, x, y, w, h) {
      switch (type) {
        case 'line': return new Line(x, y, w, h);
        case 'rect': return new Rect(x, y, w, h);
        case 'circle': return new Circle(x, y, w, h);
        default: return null;
      }
    }

    class Shape {
      clone() { return new this.constructor(...this.toJSON()); }
      toJSON() { return []; }
      contains() { return false; }
      move(dx, dy) {}
      resize() {}
      update() {}
      drawHandles(ctx) {}
    }

    class Line extends Shape {
      constructor(x, y, dx, dy) { super(); this.x1 = x; this.y1 = y; this.x2 = x + dx; this.y2 = y + dy; }
      draw(ctx) { ctx.beginPath(); ctx.moveTo(this.x1, this.y1); ctx.lineTo(this.x2, this.y2); ctx.stroke(); }
      contains(x, y) {
        const d1 = Math.hypot(x - this.x1, y - this.y1);
        const d2 = Math.hypot(x - this.x2, y - this.y2);
        const line = Math.hypot(this.x2 - this.x1, this.y2 - this.y1);
        return Math.abs(d1 + d2 - line) < 6;
      }
      move(dx, dy) { this.x1 += dx; this.y1 += dy; this.x2 += dx; this.y2 += dy; }
      resize(_, x, y) { this.x2 = x; this.y2 = y; }
      update(dx, dy) { this.x2 = this.x1 + dx; this.y2 = this.y1 + dy; }
      toJSON() { return ['line', this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1]; }
    }

    class Rect extends Shape {
      constructor(x, y, w, h) { super(); this.x = x; this.y = y; this.w = w; this.h = h; }
      draw(ctx) { ctx.strokeRect(this.x, this.y, this.w, this.h); }
      contains(x, y) { return x >= this.x && x <= this.x + this.w && y >= this.y && y <= this.y + this.h; }
      move(dx, dy) { this.x += dx; this.y += dy; }
      getHandleUnder(x, y) {
        const handles = this.getHandles();
        return handles.find(h => Math.abs(h.x - x) <= handleSize && Math.abs(h.y - y) <= handleSize)?.dir;
      }
      getHandles() {
        return [
          { x: this.x, y: this.y, dir: 'nw' },
          { x: this.x + this.w, y: this.y, dir: 'ne' },
          { x: this.x, y: this.y + this.h, dir: 'sw' },
          { x: this.x + this.w, y: this.y + this.h, dir: 'se' }
        ];
      }
      drawHandles(ctx) {
        this.getHandles().forEach(h => {
          ctx.fillRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
        });
      }
      resize(dir, x, y, startX, startY) {
        const min = 10;
        let nx = this.x, ny = this.y, nw = this.w, nh = this.h;
        if (dir.includes('n')) { nh += this.y - y; ny = y; }
        if (dir.includes('s')) { nh = y - this.y; }
        if (dir.includes('w')) { nw += this.x - x; nx = x; }
        if (dir.includes('e')) { nw = x - this.x; }
        if (nw > min) { this.x = nx; this.w = nw; }
        if (nh > min) { this.y = ny; this.h = nh; }
      }
      resize(_, x, y, sx, sy) { this.w = x - this.x; this.h = y - this.y; }
      update(month, undefined) {}
      toJSON() { return ['rect', this.x, this.y, this.w, this.h]; }
    }

    class Circle extends Shape {
      constructor(x, y, w, h) {
        super();
        this.cx = x + w / 2; this.cy = y + h / 2;
        this.r = Math.hypot(w, h) / 2;
      }
      draw(ctx) { ctx.beginPath(); ctx.arc(this.cx, this.cy, this.r, 0, 2 * Math.PI); ctx.stroke(); }
      contains(x, y) { return Math.hypot(x - this.cx, y - this.cy) <= this.r; }
      move(dx, dy) { this.cx += dx; this.cy += dy; }
      getHandleUnder(x, y) {
        const h = { x: this.cx + this.r, y: this.cy, dir: 'e' };
        return Math.abs(h.x - x) <= handleSize && Math.abs(h.y - y) <= handleSize ? 'e' : null;
      }
      drawHandles(ctx) {
        const h = { x: this.cx + this.r, y: this.cy };
        ctx.fillRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
      }
      resize(dir, x, y) {
        const nx = x - this.cx;
        const ny = y - this.cy;
        this.r = Math.hypot(nx, ny);
      }
      update(dx, dy) {
        this = new Circle(this.cx - dx/2, this.cy - dy/2, dx, dy);
      }
      toJSON() { return ['circle', this.cx, this.cy, this.r]; }
    }
  })();
  </script>
</body>
</html>

